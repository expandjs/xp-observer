{"version":3,"sources":["../../../../usr/lib/node_modules/browserify/node_modules/browser-pack/_prelude.js","index","lib/index.js","node_modules/observe-js/src/observe.js"],"names":["global","XP","require","Observer","ObjectObserver","module","exports","XPObserver","Class","initialize","value","callback","deep","assertArgument","isObservable","isFunction","self","this","_observers","_addObserver","disconnect","_disconnectObserver","_observer","undefined","enumerable","wrapper","isVoid","_isObserved","includes","_connectObserver","push","forEach","sub","observer","isObject","_getObserved","added","removed","changed","getOld","key","_removeObserver","open","isInstance","close","value_","_getObserver","find","includesDeep","pull","set","val","validate","isArray","window","detectObjectObserve","recs","records","Object","observe","Array","test","arr","id","length","deliverChangeRecords","type","unobserve","detectEval","chrome","app","runtime","navigator","getDeviceStorage","f","Function","ex","isIndex","s","toNumber","obj","areSameValue","left","right","numberIsNaN","getPathCharType","char","code","charCodeAt","noop","parsePath","path","maybeUnescapeQuote","index","nextChar","mode","newChar","actions","append","c","transition","action","typeMap","keys","pathStateMachine","isIdent","identRegExp","Path","parts","privateToken","constructorIsPrivate","Error","i","String","hasEval","getValueFrom","compiledGetValueFromFn","getPath","pathString","pathCache","invalidPath","formatAccessor","replace","dirtyCheck","cycles","MAX_DIRTY_CHECK_CYCLES","check_","testingExposeCycleCount","dirtyCheckCycleCount","objectIsEmpty","object","prop","diffIsEmpty","diff","diffObjectFromOldObject","oldObject","newValue","runEOMTasks","eomTasks","newObservedObject","state_","OPENED","discardRecords","first","obs","arrayObserve","deliver","discard","observedObjectCache","getObservedObject","dir","pop","newObservedSet","rootObj","rootObjProps","objects","indexOf","getPrototypeOf","allRootObjNonObservedProps","rec","name","observers","iterateObjects_","observerCount","record","rootObject","unobservedCount","observedSetCache","lastObservedSet","getObservedSet","UNOPENED","callback_","target_","directObserver_","id_","nextObserverId","addToAll","_allObserversCount","collectObservers","allObservers","removeFromAll","call","oldObject_","ArrayObserver","array","PathObserver","defaultValue","object_","path_","defaultValue_","CompoundObserver","reportChangesOnOpen","reportChangesOnOpen_","observed_","identFn","ObserverTransform","observable","getValueFn","setValueFn","dontPassThroughSet","observable_","getValueFn_","setValueFn_","dontPassThroughSet_","diffObjectFromChangeRecords","changeRecords","oldValues","expectedRecordTypes","oldValue","console","error","newSplice","addedCount","ArraySplice","calcSplices","current","currentStart","currentEnd","old","oldStart","oldEnd","arraySplice","intersect","start1","end1","start2","end2","mergeSplice","splices","splice","inserted","insertionOffset","intersectCount","deleteCount","prepend","slice","prototype","apply","offset","createInitialSplices","JSON","stringify","projectArraySplices","concat","hasObserve","Number","isNaN","createObject","proto","__proto__","newObject","create","getOwnPropertyNames","defineProperty","getOwnPropertyDescriptor","identStart","identPart","RegExp","beforePath","ws","ident","[","eof","inPath",".","beforeIdent","inIdent","0","number","beforeElement","'","\"","afterZero","]","inIndex","inSingleQuote","else","inDoubleQuote","afterElement","get","valid","toString","iterateObjects","str","keyIsIdent","keyForInOperator","setValueFrom","runEOM","fn","Promise","resolve","then","CLOSED","RESETTING","target","connect_","disconnect_","report_","changes","_errorThrownDuringCallback","stack","discardChanges","runningMicrotaskCheckpoint","Platform","performMicrotaskCheckpoint","anyChanged","toCheck","clearObservers","copyObject","copy","skipChanges","property","applySplices","previous","spliceArgs","addIndex","setValue","observerSentinel","needsDirectObserver","addPath","addObserver","startReset","finishReset","observedCallback_","add","update","delete","EDIT_LEAVE","EDIT_UPDATE","EDIT_ADD","EDIT_DELETE","calcEditDistances","j","rowCount","columnCount","distances","equals","north","west","spliceOperationsFromEditDistances","edits","min","northWest","reverse","prefixCount","suffixCount","minLength","Math","sharedPrefix","sharedSuffix","ops","oldIndex","searchLength","index1","index2","count","calculateSplices","currentValue","previousValue","expose","nodeType","runEOM_","observerSentinel_","hasObjectObserve"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports=require(\"./lib\");","/*jslint browser: true, devel: true, node: true, ass: true, nomen: true, unparam: true, indent: 4 */\n\n/**\n * @license\n * Copyright (c) 2015 The ExpandJS authors. All rights reserved.\n * This code may only be used under the BSD style license found at https://expandjs.github.io/LICENSE.txt\n * The complete set of authors may be found at https://expandjs.github.io/AUTHORS.txt\n * The complete set of contributors may be found at https://expandjs.github.io/CONTRIBUTORS.txt\n */\n(function (global) {\n    \"use strict\";\n\n    // Vars\n    var XP       = global.XP || require('expandjs'),\n        Observer = require('observe-js').ObjectObserver;\n\n    /*********************************************************************/\n\n    /**\n     * This class is used to provide object observing functionality.\n     *\n     * @class XPObserver\n     * @description This class is used to provide object observing functionality\n     */\n    module.exports = global.XPObserver = new XP.Class('XPObserver', {\n\n        /**\n         * @constructs\n         * @param {Array | Function | Object} value\n         * @param {Function} callback\n         * @param {boolean} [deep = false]\n         */\n        initialize: function (value, callback, deep) {\n\n            // Asserting\n            XP.assertArgument(XP.isObservable(value), 1, 'Array, Function or Object');\n            XP.assertArgument(XP.isFunction(callback), 2, 'Function');\n\n            // Vars\n            var self = this;\n\n            // Setting\n            self.value      = value;\n            self.callback   = callback;\n            self.deep       = deep;\n            self._observers = [];\n\n            // Observing\n            self._addObserver(self.value);\n\n            return self;\n        },\n\n        /*********************************************************************/\n\n        /**\n         * Disconnects the observer\n         *\n         * @method disconnect\n         * @returns {Object}\n         */\n        disconnect: function () {\n            return this._disconnectObserver(this._observer) ? this : undefined;\n        },\n\n        /*********************************************************************/\n\n        /**\n         * Adds the observer for value\n         *\n         * @method _addObserver\n         * @param {Array | Function | Object} value\n         * @param {Array | Function | Object} [wrapper]\n         * @returns {Object}\n         * @private\n         */\n        _addObserver: {\n            enumerable: false,\n            value: function (value, wrapper) {\n\n                // Asserting\n                XP.assertArgument(XP.isObservable(value), 1, 'Array, Function or Object');\n                XP.assertArgument(XP.isVoid(wrapper) || XP.isObservable(wrapper), 2, 'Array, Function or Object');\n\n                // Vars\n                var self = this;\n\n                // Checking\n                if ((XP.isObservable(value) && self._isObserved(value)) || (wrapper && !XP.includes(wrapper, value))) { return self; }\n\n                // Adding\n                if (value === self.value) { self._observer = self._connectObserver(new Observer(value)); }\n                if (value !== self.value) { self._observers.push(self._connectObserver(new Observer(value))); }\n                if (self.deep) { XP.forEach(value, function (sub) { if (XP.isObservable(sub)) { self._addObserver(sub, value); } }); }\n\n                return self;\n            }\n        },\n\n        /**\n         * Connects an observer\n         *\n         * @method _connectObserver\n         * @param {Object} observer\n         * @returns {Object}\n         * @private\n         */\n        _connectObserver: {\n            enumerable: false,\n            value: function (observer) {\n\n                // Asserting\n                XP.assertArgument(XP.isObject(observer), 1, 'Object');\n\n                // Vars\n                var self     = this,\n                    value    = self._getObserved(observer),\n                    callback = function (added, removed, changed, getOld) {\n\n                        // Updating\n                        XP.forEach(added, function (sub) { if (XP.isObservable(sub)) { self._addObserver(sub, value); } });\n                        XP.forEach(changed, function (sub, key) { if (XP.isObservable(sub)) { self._addObserver(sub, value)._removeObserver(getOld(key)); } });\n                        XP.forEach(removed, function (sub, key) { if (XP.isObservable(getOld(key))) { self._removeObserver(getOld(key)); } });\n\n                        return self.callback(self.value);\n                    };\n\n                // Connecting\n                if (value) { observer.open(callback); } else { return observer; }\n                if (observer === self._observer) { self._observers.forEach(function (observer) { observer.open(callback); }); }\n\n                return observer;\n            }\n        },\n\n        /**\n         * Disconnects an observer\n         *\n         * @method _disconnectObserver\n         * @param {Object} observer\n         * @returns {Object}\n         * @private\n         */\n        _disconnectObserver: {\n            enumerable: false,\n            value: function (observer) {\n\n                // Asserting\n                XP.assertArgument(XP.isObject(observer), 1, 'Object');\n\n                // Vars\n                var self = this;\n\n                // Disconnecting\n                if (XP.isInstance(observer, Observer)) { observer.close(); } else { return observer; }\n                if (observer === self._observer) { self._observers.forEach(function (observer) { observer.close(); }); }\n\n                return observer;\n            }\n        },\n\n        /**\n         * Returns the value of observer\n         *\n         * @method _getObserved\n         * @param {Object} observer\n         * @returns {Array | Object}\n         * @private\n         */\n        _getObserved: {\n            enumerable: false,\n            value: function (observer) {\n                XP.assertArgument(XP.isObject(observer), 1, 'Object');\n                return observer.value_;\n            }\n        },\n\n        /**\n         * Returns the observer of value\n         *\n         * @method _getObserver\n         * @param {Array | Function | Object} value\n         * @returns {Object | undefined}\n         * @private\n         */\n        _getObserver: {\n            enumerable: false,\n            value: function (value) {\n                XP.assertArgument(XP.isObservable(value), 1, 'Array, Function or Object');\n                return XP.find(this._observers, {value_: value});\n            }\n        },\n\n        /**\n         * Returns true if value is observed\n         *\n         * @method _isObserved\n         * @param {Array | Function | Object} value\n         * @returns {boolean}\n         * @private\n         */\n        _isObserved: {\n            enumerable: false,\n            value: function (value) {\n                XP.assertArgument(XP.isObservable(value), 1, 'Array, Function or Object');\n                return value === this.value ? !!this._observer : !!this._getObserver(value);\n            }\n        },\n\n        /**\n         * Removes the observer of value\n         *\n         * @method _removeObserver\n         * @param {Array | Function | Object} value\n         * @returns {Object}\n         * @private\n         */\n        _removeObserver: {\n            enumerable: false,\n            value: function (value) {\n\n                // Asserting\n                XP.assertArgument(XP.isObservable(value), 1, 'Array, Function or Object');\n\n                // Vars\n                var self     = this,\n                    observer = self._getObserver(value);\n\n                // Checking\n                if (!observer || XP.includesDeep(self.value, value)) { return self; }\n\n                // Removing\n                XP.pull(self._observers, self._disconnectObserver(observer));\n                XP.forEach(self.deep ? value : {}, function (sub) { if (XP.isObservable(sub)) { self._removeObserver(sub); } });\n\n                return self;\n            }\n        },\n\n        /*********************************************************************/\n\n        /**\n         * TODO DOC\n         *\n         * @property callback\n         * @type Function\n         */\n        callback: {\n            set: function (val) { return XP.isFunction(val) ? function () { return val(); } : null; },\n            validate: function (val) { return !XP.isFunction(val) && 'Function'; }\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @property deep\n         * @type boolean\n         */\n        deep: {\n            set: function (val) { return !!val; }\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @property value\n         * @type Array | Function | Object\n         */\n        value: {\n            set: function (val) { return this.value || val; },\n            validate: function (val) { return !XP.isObservable(val) && 'Array, Function or Object'; }\n        },\n\n        /*********************************************************************/\n\n        /**\n         * TODO DOC\n         *\n         * @property _observer\n         * @type Object\n         * @private\n         */\n        _observer: {\n            enumerable: false,\n            set: function (val) { return this._observer || val; },\n            validate: function (val) { return !XP.isObject(val) && 'Object'; }\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @property _observers\n         * @type Array\n         * @private\n         */\n        _observers: {\n            enumerable: false,\n            set: function (val) { return this._observers || val; },\n            validate: function (val) { return !XP.isArray(val) && 'Array'; }\n        }\n    });\n\n}(typeof window !== \"undefined\" ? window : global));\n","/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(global) {\n  'use strict';\n\n  var testingExposeCycleCount = global.testingExposeCycleCount;\n\n  // Detect and do basic sanity checking on Object/Array.observe.\n  function detectObjectObserve() {\n    if (typeof Object.observe !== 'function' ||\n        typeof Array.observe !== 'function') {\n      return false;\n    }\n\n    var records = [];\n\n    function callback(recs) {\n      records = recs;\n    }\n\n    var test = {};\n    var arr = [];\n    Object.observe(test, callback);\n    Array.observe(arr, callback);\n    test.id = 1;\n    test.id = 2;\n    delete test.id;\n    arr.push(1, 2);\n    arr.length = 0;\n\n    Object.deliverChangeRecords(callback);\n    if (records.length !== 5)\n      return false;\n\n    if (records[0].type != 'add' ||\n        records[1].type != 'update' ||\n        records[2].type != 'delete' ||\n        records[3].type != 'splice' ||\n        records[4].type != 'splice') {\n      return false;\n    }\n\n    Object.unobserve(test, callback);\n    Array.unobserve(arr, callback);\n\n    return true;\n  }\n\n  var hasObserve = detectObjectObserve();\n\n  function detectEval() {\n    // Don't test for eval if we're running in a Chrome App environment.\n    // We check for APIs set that only exist in a Chrome App context.\n    if (typeof chrome !== 'undefined' && chrome.app && chrome.app.runtime) {\n      return false;\n    }\n\n    // Firefox OS Apps do not allow eval. This feature detection is very hacky\n    // but even if some other platform adds support for this function this code\n    // will continue to work.\n    if (typeof navigator != 'undefined' && navigator.getDeviceStorage) {\n      return false;\n    }\n\n    try {\n      var f = new Function('', 'return true;');\n      return f();\n    } catch (ex) {\n      return false;\n    }\n  }\n\n  var hasEval = detectEval();\n\n  function isIndex(s) {\n    return +s === s >>> 0 && s !== '';\n  }\n\n  function toNumber(s) {\n    return +s;\n  }\n\n  function isObject(obj) {\n    return obj === Object(obj);\n  }\n\n  var numberIsNaN = global.Number.isNaN || function(value) {\n    return typeof value === 'number' && global.isNaN(value);\n  };\n\n  function areSameValue(left, right) {\n    if (left === right)\n      return left !== 0 || 1 / left === 1 / right;\n    if (numberIsNaN(left) && numberIsNaN(right))\n      return true;\n\n    return left !== left && right !== right;\n  }\n\n  var createObject = ('__proto__' in {}) ?\n    function(obj) { return obj; } :\n    function(obj) {\n      var proto = obj.__proto__;\n      if (!proto)\n        return obj;\n      var newObject = Object.create(proto);\n      Object.getOwnPropertyNames(obj).forEach(function(name) {\n        Object.defineProperty(newObject, name,\n                             Object.getOwnPropertyDescriptor(obj, name));\n      });\n      return newObject;\n    };\n\n  var identStart = '[\\$_a-zA-Z]';\n  var identPart = '[\\$_a-zA-Z0-9]';\n  var identRegExp = new RegExp('^' + identStart + '+' + identPart + '*' + '$');\n\n  function getPathCharType(char) {\n    if (char === undefined)\n      return 'eof';\n\n    var code = char.charCodeAt(0);\n\n    switch(code) {\n      case 0x5B: // [\n      case 0x5D: // ]\n      case 0x2E: // .\n      case 0x22: // \"\n      case 0x27: // '\n      case 0x30: // 0\n        return char;\n\n      case 0x5F: // _\n      case 0x24: // $\n        return 'ident';\n\n      case 0x20: // Space\n      case 0x09: // Tab\n      case 0x0A: // Newline\n      case 0x0D: // Return\n      case 0xA0:  // No-break space\n      case 0xFEFF:  // Byte Order Mark\n      case 0x2028:  // Line Separator\n      case 0x2029:  // Paragraph Separator\n        return 'ws';\n    }\n\n    // a-z, A-Z\n    if ((0x61 <= code && code <= 0x7A) || (0x41 <= code && code <= 0x5A))\n      return 'ident';\n\n    // 1-9\n    if (0x31 <= code && code <= 0x39)\n      return 'number';\n\n    return 'else';\n  }\n\n  var pathStateMachine = {\n    'beforePath': {\n      'ws': ['beforePath'],\n      'ident': ['inIdent', 'append'],\n      '[': ['beforeElement'],\n      'eof': ['afterPath']\n    },\n\n    'inPath': {\n      'ws': ['inPath'],\n      '.': ['beforeIdent'],\n      '[': ['beforeElement'],\n      'eof': ['afterPath']\n    },\n\n    'beforeIdent': {\n      'ws': ['beforeIdent'],\n      'ident': ['inIdent', 'append']\n    },\n\n    'inIdent': {\n      'ident': ['inIdent', 'append'],\n      '0': ['inIdent', 'append'],\n      'number': ['inIdent', 'append'],\n      'ws': ['inPath', 'push'],\n      '.': ['beforeIdent', 'push'],\n      '[': ['beforeElement', 'push'],\n      'eof': ['afterPath', 'push']\n    },\n\n    'beforeElement': {\n      'ws': ['beforeElement'],\n      '0': ['afterZero', 'append'],\n      'number': ['inIndex', 'append'],\n      \"'\": ['inSingleQuote', 'append', ''],\n      '\"': ['inDoubleQuote', 'append', '']\n    },\n\n    'afterZero': {\n      'ws': ['afterElement', 'push'],\n      ']': ['inPath', 'push']\n    },\n\n    'inIndex': {\n      '0': ['inIndex', 'append'],\n      'number': ['inIndex', 'append'],\n      'ws': ['afterElement'],\n      ']': ['inPath', 'push']\n    },\n\n    'inSingleQuote': {\n      \"'\": ['afterElement'],\n      'eof': ['error'],\n      'else': ['inSingleQuote', 'append']\n    },\n\n    'inDoubleQuote': {\n      '\"': ['afterElement'],\n      'eof': ['error'],\n      'else': ['inDoubleQuote', 'append']\n    },\n\n    'afterElement': {\n      'ws': ['afterElement'],\n      ']': ['inPath', 'push']\n    }\n  };\n\n  function noop() {}\n\n  function parsePath(path) {\n    var keys = [];\n    var index = -1;\n    var c, newChar, key, type, transition, action, typeMap, mode = 'beforePath';\n\n    var actions = {\n      push: function() {\n        if (key === undefined)\n          return;\n\n        keys.push(key);\n        key = undefined;\n      },\n\n      append: function() {\n        if (key === undefined)\n          key = newChar;\n        else\n          key += newChar;\n      }\n    };\n\n    function maybeUnescapeQuote() {\n      if (index >= path.length)\n        return;\n\n      var nextChar = path[index + 1];\n      if ((mode == 'inSingleQuote' && nextChar == \"'\") ||\n          (mode == 'inDoubleQuote' && nextChar == '\"')) {\n        index++;\n        newChar = nextChar;\n        actions.append();\n        return true;\n      }\n    }\n\n    while (mode) {\n      index++;\n      c = path[index];\n\n      if (c == '\\\\' && maybeUnescapeQuote(mode))\n        continue;\n\n      type = getPathCharType(c);\n      typeMap = pathStateMachine[mode];\n      transition = typeMap[type] || typeMap['else'] || 'error';\n\n      if (transition == 'error')\n        return; // parse error;\n\n      mode = transition[0];\n      action = actions[transition[1]] || noop;\n      newChar = transition[2] === undefined ? c : transition[2];\n      action();\n\n      if (mode === 'afterPath') {\n        return keys;\n      }\n    }\n\n    return; // parse error\n  }\n\n  function isIdent(s) {\n    return identRegExp.test(s);\n  }\n\n  var constructorIsPrivate = {};\n\n  function Path(parts, privateToken) {\n    if (privateToken !== constructorIsPrivate)\n      throw Error('Use Path.get to retrieve path objects');\n\n    for (var i = 0; i < parts.length; i++) {\n      this.push(String(parts[i]));\n    }\n\n    if (hasEval && this.length) {\n      this.getValueFrom = this.compiledGetValueFromFn();\n    }\n  }\n\n  // TODO(rafaelw): Make simple LRU cache\n  var pathCache = {};\n\n  function getPath(pathString) {\n    if (pathString instanceof Path)\n      return pathString;\n\n    if (pathString == null || pathString.length == 0)\n      pathString = '';\n\n    if (typeof pathString != 'string') {\n      if (isIndex(pathString.length)) {\n        // Constructed with array-like (pre-parsed) keys\n        return new Path(pathString, constructorIsPrivate);\n      }\n\n      pathString = String(pathString);\n    }\n\n    var path = pathCache[pathString];\n    if (path)\n      return path;\n\n    var parts = parsePath(pathString);\n    if (!parts)\n      return invalidPath;\n\n    path = new Path(parts, constructorIsPrivate);\n    pathCache[pathString] = path;\n    return path;\n  }\n\n  Path.get = getPath;\n\n  function formatAccessor(key) {\n    if (isIndex(key)) {\n      return '[' + key + ']';\n    } else {\n      return '[\"' + key.replace(/\"/g, '\\\\\"') + '\"]';\n    }\n  }\n\n  Path.prototype = createObject({\n    __proto__: [],\n    valid: true,\n\n    toString: function() {\n      var pathString = '';\n      for (var i = 0; i < this.length; i++) {\n        var key = this[i];\n        if (isIdent(key)) {\n          pathString += i ? '.' + key : key;\n        } else {\n          pathString += formatAccessor(key);\n        }\n      }\n\n      return pathString;\n    },\n\n    getValueFrom: function(obj, defaultValue) {\n      for (var i = 0; i < this.length; i++) {\n        var key = this[i];\n        if (obj == null || !(key in obj))\n          return defaultValue;\n        obj = obj[key];\n      }\n      return obj;\n    },\n\n    iterateObjects: function(obj, observe) {\n      for (var i = 0; i < this.length; i++) {\n        if (i)\n          obj = obj[this[i - 1]];\n        if (!isObject(obj))\n          return;\n        observe(obj, this[i]);\n      }\n    },\n\n    compiledGetValueFromFn: function() {\n      var str = '';\n      var pathString = 'obj';\n      str += 'if (obj != null';\n      var i = 0;\n      var key;\n      for (; i < (this.length - 1); i++) {\n        key = this[i];\n        pathString += isIdent(key) ? '.' + key : formatAccessor(key);\n        str += ' &&\\n    ' + pathString + ' != null';\n      }\n\n      key = this[i];\n      var keyIsIdent = isIdent(key);\n      var keyForInOperator = keyIsIdent ? '\"' + key.replace(/\"/g, '\\\\\"') + '\"' : key;\n      str += ' &&\\n    ' + keyForInOperator + ' in ' + pathString + ')\\n';\n      pathString += keyIsIdent ? '.' + key : formatAccessor(key);\n\n      str += '  return ' + pathString + ';\\nelse\\n  return defaultValue;';\n      return new Function('obj', 'defaultValue', str);\n    },\n\n    setValueFrom: function(obj, value) {\n      if (!this.length)\n        return false;\n\n      for (var i = 0; i < this.length - 1; i++) {\n        if (!isObject(obj))\n          return false;\n        obj = obj[this[i]];\n      }\n\n      if (!isObject(obj))\n        return false;\n\n      obj[this[i]] = value;\n      return true;\n    }\n  });\n\n  var invalidPath = new Path('', constructorIsPrivate);\n  invalidPath.valid = false;\n  invalidPath.getValueFrom = invalidPath.setValueFrom = function() {};\n\n  var MAX_DIRTY_CHECK_CYCLES = 1000;\n\n  function dirtyCheck(observer) {\n    var cycles = 0;\n    while (cycles < MAX_DIRTY_CHECK_CYCLES && observer.check_()) {\n      cycles++;\n    }\n    if (testingExposeCycleCount)\n      global.dirtyCheckCycleCount = cycles;\n\n    return cycles > 0;\n  }\n\n  function objectIsEmpty(object) {\n    for (var prop in object)\n      return false;\n    return true;\n  }\n\n  function diffIsEmpty(diff) {\n    return objectIsEmpty(diff.added) &&\n           objectIsEmpty(diff.removed) &&\n           objectIsEmpty(diff.changed);\n  }\n\n  function diffObjectFromOldObject(object, oldObject) {\n    var added = {};\n    var removed = {};\n    var changed = {};\n    var prop;\n\n    for (prop in oldObject) {\n      var newValue = object[prop];\n\n      if (newValue !== undefined && newValue === oldObject[prop])\n        continue;\n\n      if (!(prop in object)) {\n        removed[prop] = undefined;\n        continue;\n      }\n\n      if (newValue !== oldObject[prop])\n        changed[prop] = newValue;\n    }\n\n    for (prop in object) {\n      if (prop in oldObject)\n        continue;\n\n      added[prop] = object[prop];\n    }\n\n    if (Array.isArray(object) && object.length !== oldObject.length)\n      changed.length = object.length;\n\n    return {\n      added: added,\n      removed: removed,\n      changed: changed\n    };\n  }\n\n  var eomTasks = [];\n  function runEOMTasks() {\n    if (!eomTasks.length)\n      return false;\n\n    for (var i = 0; i < eomTasks.length; i++) {\n      eomTasks[i]();\n    }\n    eomTasks.length = 0;\n    return true;\n  }\n\n  var runEOM = hasObserve ? (function(){\n    return function(fn) {\n      return Promise.resolve().then(fn);\n    };\n  })() :\n  (function() {\n    return function(fn) {\n      eomTasks.push(fn);\n    };\n  })();\n\n  var observedObjectCache = [];\n\n  function newObservedObject() {\n    var observer;\n    var object;\n    var discardRecords = false;\n    var first = true;\n\n    function callback(records) {\n      if (observer && observer.state_ === OPENED && !discardRecords)\n        observer.check_(records);\n    }\n\n    return {\n      open: function(obs) {\n        if (observer)\n          throw Error('ObservedObject in use');\n\n        if (!first)\n          Object.deliverChangeRecords(callback);\n\n        observer = obs;\n        first = false;\n      },\n      observe: function(obj, arrayObserve) {\n        object = obj;\n        if (arrayObserve)\n          Array.observe(object, callback);\n        else\n          Object.observe(object, callback);\n      },\n      deliver: function(discard) {\n        discardRecords = discard;\n        Object.deliverChangeRecords(callback);\n        discardRecords = false;\n      },\n      close: function() {\n        observer = undefined;\n        Object.unobserve(object, callback);\n        observedObjectCache.push(this);\n      }\n    };\n  }\n\n  /*\n   * The observedSet abstraction is a perf optimization which reduces the total\n   * number of Object.observe observations of a set of objects. The idea is that\n   * groups of Observers will have some object dependencies in common and this\n   * observed set ensures that each object in the transitive closure of\n   * dependencies is only observed once. The observedSet acts as a write barrier\n   * such that whenever any change comes through, all Observers are checked for\n   * changed values.\n   *\n   * Note that this optimization is explicitly moving work from setup-time to\n   * change-time.\n   *\n   * TODO(rafaelw): Implement \"garbage collection\". In order to move work off\n   * the critical path, when Observers are closed, their observed objects are\n   * not Object.unobserve(d). As a result, it's possible that if the observedSet\n   * is kept open, but some Observers have been closed, it could cause \"leaks\"\n   * (prevent otherwise collectable objects from being collected). At some\n   * point, we should implement incremental \"gc\" which keeps a list of\n   * observedSets which may need clean-up and does small amounts of cleanup on a\n   * timeout until all is clean.\n   */\n\n  function getObservedObject(observer, object, arrayObserve) {\n    var dir = observedObjectCache.pop() || newObservedObject();\n    dir.open(observer);\n    dir.observe(object, arrayObserve);\n    return dir;\n  }\n\n  var observedSetCache = [];\n\n  function newObservedSet() {\n    var observerCount = 0;\n    var observers = [];\n    var objects = [];\n    var rootObj;\n    var rootObjProps;\n\n    function observe(obj, prop) {\n      if (!obj)\n        return;\n\n      if (obj === rootObj)\n        rootObjProps[prop] = true;\n\n      if (objects.indexOf(obj) < 0) {\n        objects.push(obj);\n        Object.observe(obj, callback);\n      }\n\n      observe(Object.getPrototypeOf(obj), prop);\n    }\n\n    function allRootObjNonObservedProps(recs) {\n      for (var i = 0; i < recs.length; i++) {\n        var rec = recs[i];\n        if (rec.object !== rootObj ||\n            rootObjProps[rec.name] ||\n            rec.type === 'setPrototype') {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    function callback(recs) {\n      if (allRootObjNonObservedProps(recs))\n        return;\n\n      var i, observer;\n      for (i = 0; i < observers.length; i++) {\n        observer = observers[i];\n        if (observer.state_ == OPENED) {\n          observer.iterateObjects_(observe);\n        }\n      }\n\n      for (i = 0; i < observers.length; i++) {\n        observer = observers[i];\n        if (observer.state_ == OPENED) {\n          observer.check_();\n        }\n      }\n    }\n\n    var record = {\n      objects: objects,\n      get rootObject() { return rootObj; },\n      set rootObject(value) {\n        rootObj = value;\n        rootObjProps = {};\n      },\n      open: function(obs, object) {\n        observers.push(obs);\n        observerCount++;\n        obs.iterateObjects_(observe);\n      },\n      close: function(obs) {\n        observerCount--;\n        if (observerCount > 0) {\n          return;\n        }\n\n        for (var i = 0; i < objects.length; i++) {\n          Object.unobserve(objects[i], callback);\n          Observer.unobservedCount++;\n        }\n\n        observers.length = 0;\n        objects.length = 0;\n        rootObj = undefined;\n        rootObjProps = undefined;\n        observedSetCache.push(this);\n        if (lastObservedSet === this)\n          lastObservedSet = null;\n      },\n    };\n\n    return record;\n  }\n\n  var lastObservedSet;\n\n  function getObservedSet(observer, obj) {\n    if (!lastObservedSet || lastObservedSet.rootObject !== obj) {\n      lastObservedSet = observedSetCache.pop() || newObservedSet();\n      lastObservedSet.rootObject = obj;\n    }\n    lastObservedSet.open(observer, obj);\n    return lastObservedSet;\n  }\n\n  var UNOPENED = 0;\n  var OPENED = 1;\n  var CLOSED = 2;\n  var RESETTING = 3;\n\n  var nextObserverId = 1;\n\n  function Observer() {\n    this.state_ = UNOPENED;\n    this.callback_ = undefined;\n    this.target_ = undefined; // TODO(rafaelw): Should be WeakRef\n    this.directObserver_ = undefined;\n    this.value_ = undefined;\n    this.id_ = nextObserverId++;\n  }\n\n  Observer.prototype = {\n    open: function(callback, target) {\n      if (this.state_ != UNOPENED)\n        throw Error('Observer has already been opened.');\n\n      addToAll(this);\n      this.callback_ = callback;\n      this.target_ = target;\n      this.connect_();\n      this.state_ = OPENED;\n      return this.value_;\n    },\n\n    close: function() {\n      if (this.state_ != OPENED)\n        return;\n\n      removeFromAll(this);\n      this.disconnect_();\n      this.value_ = undefined;\n      this.callback_ = undefined;\n      this.target_ = undefined;\n      this.state_ = CLOSED;\n    },\n\n    deliver: function() {\n      if (this.state_ != OPENED)\n        return;\n\n      dirtyCheck(this);\n    },\n\n    report_: function(changes) {\n      try {\n        this.callback_.apply(this.target_, changes);\n      } catch (ex) {\n        Observer._errorThrownDuringCallback = true;\n        console.error('Exception caught during observer callback: ' +\n                       (ex.stack || ex));\n      }\n    },\n\n    discardChanges: function() {\n      this.check_(undefined, true);\n      return this.value_;\n    }\n  };\n\n  var collectObservers = !hasObserve;\n  var allObservers;\n  Observer._allObserversCount = 0;\n\n  if (collectObservers) {\n    allObservers = [];\n  }\n\n  function addToAll(observer) {\n    Observer._allObserversCount++;\n    if (!collectObservers)\n      return;\n\n    allObservers.push(observer);\n  }\n\n  function removeFromAll(observer) {\n    Observer._allObserversCount--;\n  }\n\n  var runningMicrotaskCheckpoint = false;\n\n  global.Platform = global.Platform || {};\n\n  global.Platform.performMicrotaskCheckpoint = function() {\n    if (runningMicrotaskCheckpoint)\n      return;\n\n    if (!collectObservers)\n      return;\n\n    runningMicrotaskCheckpoint = true;\n\n    var cycles = 0;\n    var anyChanged, toCheck;\n\n    do {\n      cycles++;\n      toCheck = allObservers;\n      allObservers = [];\n      anyChanged = false;\n\n      for (var i = 0; i < toCheck.length; i++) {\n        var observer = toCheck[i];\n        if (observer.state_ != OPENED)\n          continue;\n\n        if (observer.check_())\n          anyChanged = true;\n\n        allObservers.push(observer);\n      }\n      if (runEOMTasks())\n        anyChanged = true;\n    } while (cycles < MAX_DIRTY_CHECK_CYCLES && anyChanged);\n\n    if (testingExposeCycleCount)\n      global.dirtyCheckCycleCount = cycles;\n\n    runningMicrotaskCheckpoint = false;\n  };\n\n  if (collectObservers) {\n    global.Platform.clearObservers = function() {\n      allObservers = [];\n    };\n  }\n\n  function ObjectObserver(object) {\n    Observer.call(this);\n    this.value_ = object;\n    this.oldObject_ = undefined;\n  }\n\n  ObjectObserver.prototype = createObject({\n    __proto__: Observer.prototype,\n\n    arrayObserve: false,\n\n    connect_: function(callback, target) {\n      if (hasObserve) {\n        this.directObserver_ = getObservedObject(this, this.value_,\n                                                 this.arrayObserve);\n      } else {\n        this.oldObject_ = this.copyObject(this.value_);\n      }\n\n    },\n\n    copyObject: function(object) {\n      var copy = Array.isArray(object) ? [] : {};\n      for (var prop in object) {\n        copy[prop] = object[prop];\n      }\n      if (Array.isArray(object))\n        copy.length = object.length;\n      return copy;\n    },\n\n    check_: function(changeRecords, skipChanges) {\n      var diff;\n      var oldValues;\n      if (hasObserve) {\n        if (!changeRecords)\n          return false;\n\n        oldValues = {};\n        diff = diffObjectFromChangeRecords(this.value_, changeRecords,\n                                           oldValues);\n      } else {\n        oldValues = this.oldObject_;\n        diff = diffObjectFromOldObject(this.value_, this.oldObject_);\n      }\n\n      if (diffIsEmpty(diff))\n        return false;\n\n      if (!hasObserve)\n        this.oldObject_ = this.copyObject(this.value_);\n\n      this.report_([\n        diff.added || {},\n        diff.removed || {},\n        diff.changed || {},\n        function(property) {\n          return oldValues[property];\n        }\n      ]);\n\n      return true;\n    },\n\n    disconnect_: function() {\n      if (hasObserve) {\n        this.directObserver_.close();\n        this.directObserver_ = undefined;\n      } else {\n        this.oldObject_ = undefined;\n      }\n    },\n\n    deliver: function() {\n      if (this.state_ != OPENED)\n        return;\n\n      if (hasObserve)\n        this.directObserver_.deliver(false);\n      else\n        dirtyCheck(this);\n    },\n\n    discardChanges: function() {\n      if (this.directObserver_)\n        this.directObserver_.deliver(true);\n      else\n        this.oldObject_ = this.copyObject(this.value_);\n\n      return this.value_;\n    }\n  });\n\n  function ArrayObserver(array) {\n    if (!Array.isArray(array))\n      throw Error('Provided object is not an Array');\n    ObjectObserver.call(this, array);\n  }\n\n  ArrayObserver.prototype = createObject({\n\n    __proto__: ObjectObserver.prototype,\n\n    arrayObserve: true,\n\n    copyObject: function(arr) {\n      return arr.slice();\n    },\n\n    check_: function(changeRecords) {\n      var splices;\n      if (hasObserve) {\n        if (!changeRecords)\n          return false;\n        splices = projectArraySplices(this.value_, changeRecords);\n      } else {\n        splices = calcSplices(this.value_, 0, this.value_.length,\n                              this.oldObject_, 0, this.oldObject_.length);\n      }\n\n      if (!splices || !splices.length)\n        return false;\n\n      if (!hasObserve)\n        this.oldObject_ = this.copyObject(this.value_);\n\n      this.report_([splices]);\n      return true;\n    }\n  });\n\n  ArrayObserver.applySplices = function(previous, current, splices) {\n    splices.forEach(function(splice) {\n      var spliceArgs = [splice.index, splice.removed.length];\n      var addIndex = splice.index;\n      while (addIndex < splice.index + splice.addedCount) {\n        spliceArgs.push(current[addIndex]);\n        addIndex++;\n      }\n\n      Array.prototype.splice.apply(previous, spliceArgs);\n    });\n  };\n\n  function PathObserver(object, path, defaultValue) {\n    Observer.call(this);\n\n    this.object_ = object;\n    this.path_ = getPath(path);\n    this.defaultValue_ = defaultValue;\n    this.directObserver_ = undefined;\n  }\n\n  PathObserver.prototype = createObject({\n    __proto__: Observer.prototype,\n\n    get path() {\n      return this.path_;\n    },\n\n    connect_: function() {\n      if (hasObserve)\n        this.directObserver_ = getObservedSet(this, this.object_);\n\n      this.check_(undefined, true);\n    },\n\n    disconnect_: function() {\n      this.value_ = undefined;\n\n      if (this.directObserver_) {\n        this.directObserver_.close(this);\n        this.directObserver_ = undefined;\n      }\n    },\n\n    iterateObjects_: function(observe) {\n      this.path_.iterateObjects(this.object_, observe);\n    },\n\n    check_: function(changeRecords, skipChanges) {\n      var oldValue = this.value_;\n      this.value_ = this.path_.getValueFrom(this.object_, this.defaultValue_);\n      if (skipChanges || areSameValue(this.value_, oldValue))\n        return false;\n\n      this.report_([this.value_, oldValue, this]);\n      return true;\n    },\n\n    setValue: function(newValue) {\n      if (this.path_)\n        this.path_.setValueFrom(this.object_, newValue);\n    }\n  });\n\n  function CompoundObserver(reportChangesOnOpen) {\n    Observer.call(this);\n\n    this.reportChangesOnOpen_ = reportChangesOnOpen;\n    this.value_ = [];\n    this.directObserver_ = undefined;\n    this.observed_ = [];\n  }\n\n  var observerSentinel = {};\n\n  CompoundObserver.prototype = createObject({\n    __proto__: Observer.prototype,\n\n    connect_: function() {\n      if (hasObserve) {\n        var object;\n        var needsDirectObserver = false;\n        for (var i = 0; i < this.observed_.length; i += 2) {\n          object = this.observed_[i];\n          if (object !== observerSentinel) {\n            needsDirectObserver = true;\n            break;\n          }\n        }\n\n        if (needsDirectObserver)\n          this.directObserver_ = getObservedSet(this, object);\n      }\n\n      this.check_(undefined, !this.reportChangesOnOpen_);\n    },\n\n    disconnect_: function() {\n      for (var i = 0; i < this.observed_.length; i += 2) {\n        if (this.observed_[i] === observerSentinel)\n          this.observed_[i + 1].close();\n      }\n      this.observed_.length = 0;\n      this.value_.length = 0;\n\n      if (this.directObserver_) {\n        this.directObserver_.close(this);\n        this.directObserver_ = undefined;\n      }\n    },\n\n    addPath: function(object, path) {\n      if (this.state_ != UNOPENED && this.state_ != RESETTING)\n        throw Error('Cannot add paths once started.');\n\n      path = getPath(path);\n      this.observed_.push(object, path);\n      if (!this.reportChangesOnOpen_)\n        return;\n      var index = this.observed_.length / 2 - 1;\n      this.value_[index] = path.getValueFrom(object);\n    },\n\n    addObserver: function(observer) {\n      if (this.state_ != UNOPENED && this.state_ != RESETTING)\n        throw Error('Cannot add observers once started.');\n\n      this.observed_.push(observerSentinel, observer);\n      if (!this.reportChangesOnOpen_)\n        return;\n      var index = this.observed_.length / 2 - 1;\n      this.value_[index] = observer.open(this.deliver, this);\n    },\n\n    startReset: function() {\n      if (this.state_ != OPENED)\n        throw Error('Can only reset while open');\n\n      this.state_ = RESETTING;\n      this.disconnect_();\n    },\n\n    finishReset: function() {\n      if (this.state_ != RESETTING)\n        throw Error('Can only finishReset after startReset');\n      this.state_ = OPENED;\n      this.connect_();\n\n      return this.value_;\n    },\n\n    iterateObjects_: function(observe) {\n      var object;\n      for (var i = 0; i < this.observed_.length; i += 2) {\n        object = this.observed_[i];\n        if (object !== observerSentinel)\n          this.observed_[i + 1].iterateObjects(object, observe);\n      }\n    },\n\n    check_: function(changeRecords, skipChanges) {\n      var oldValues;\n      for (var i = 0; i < this.observed_.length; i += 2) {\n        var object = this.observed_[i];\n        var path = this.observed_[i+1];\n        var value;\n        if (object === observerSentinel) {\n          var observable = path;\n          value = this.state_ === UNOPENED ?\n              observable.open(this.deliver, this) :\n              observable.discardChanges();\n        } else {\n          value = path.getValueFrom(object);\n        }\n\n        if (skipChanges) {\n          this.value_[i / 2] = value;\n          continue;\n        }\n\n        if (areSameValue(value, this.value_[i / 2]))\n          continue;\n\n        oldValues = oldValues || [];\n        oldValues[i / 2] = this.value_[i / 2];\n        this.value_[i / 2] = value;\n      }\n\n      if (!oldValues)\n        return false;\n\n      // TODO(rafaelw): Having observed_ as the third callback arg here is\n      // pretty lame API. Fix.\n      this.report_([this.value_, oldValues, this.observed_]);\n      return true;\n    }\n  });\n\n  function identFn(value) { return value; }\n\n  function ObserverTransform(observable, getValueFn, setValueFn,\n                             dontPassThroughSet) {\n    this.callback_ = undefined;\n    this.target_ = undefined;\n    this.value_ = undefined;\n    this.observable_ = observable;\n    this.getValueFn_ = getValueFn || identFn;\n    this.setValueFn_ = setValueFn || identFn;\n    // TODO(rafaelw): This is a temporary hack. PolymerExpressions needs this\n    // at the moment because of a bug in it's dependency tracking.\n    this.dontPassThroughSet_ = dontPassThroughSet;\n  }\n\n  ObserverTransform.prototype = {\n    open: function(callback, target) {\n      this.callback_ = callback;\n      this.target_ = target;\n      this.value_ =\n          this.getValueFn_(this.observable_.open(this.observedCallback_, this));\n      return this.value_;\n    },\n\n    observedCallback_: function(value) {\n      value = this.getValueFn_(value);\n      if (areSameValue(value, this.value_))\n        return;\n      var oldValue = this.value_;\n      this.value_ = value;\n      this.callback_.call(this.target_, this.value_, oldValue);\n    },\n\n    discardChanges: function() {\n      this.value_ = this.getValueFn_(this.observable_.discardChanges());\n      return this.value_;\n    },\n\n    deliver: function() {\n      return this.observable_.deliver();\n    },\n\n    setValue: function(value) {\n      value = this.setValueFn_(value);\n      if (!this.dontPassThroughSet_ && this.observable_.setValue)\n        return this.observable_.setValue(value);\n    },\n\n    close: function() {\n      if (this.observable_)\n        this.observable_.close();\n      this.callback_ = undefined;\n      this.target_ = undefined;\n      this.observable_ = undefined;\n      this.value_ = undefined;\n      this.getValueFn_ = undefined;\n      this.setValueFn_ = undefined;\n    }\n  };\n\n  var expectedRecordTypes = {\n    add: true,\n    update: true,\n    delete: true\n  };\n\n  function diffObjectFromChangeRecords(object, changeRecords, oldValues) {\n    var added = {};\n    var removed = {};\n\n    for (var i = 0; i < changeRecords.length; i++) {\n      var record = changeRecords[i];\n      if (!expectedRecordTypes[record.type]) {\n        console.error('Unknown changeRecord type: ' + record.type);\n        console.error(record);\n        continue;\n      }\n\n      if (!(record.name in oldValues))\n        oldValues[record.name] = record.oldValue;\n\n      if (record.type == 'update')\n        continue;\n\n      if (record.type == 'add') {\n        if (record.name in removed)\n          delete removed[record.name];\n        else\n          added[record.name] = true;\n\n        continue;\n      }\n\n      // type = 'delete'\n      if (record.name in added) {\n        delete added[record.name];\n        delete oldValues[record.name];\n      } else {\n        removed[record.name] = true;\n      }\n    }\n\n    var prop;\n    for (prop in added)\n      added[prop] = object[prop];\n\n    for (prop in removed)\n      removed[prop] = undefined;\n\n    var changed = {};\n    for (prop in oldValues) {\n      if (prop in added || prop in removed)\n        continue;\n\n      var newValue = object[prop];\n      if (oldValues[prop] !== newValue)\n        changed[prop] = newValue;\n    }\n\n    return {\n      added: added,\n      removed: removed,\n      changed: changed\n    };\n  }\n\n  function newSplice(index, removed, addedCount) {\n    return {\n      index: index,\n      removed: removed,\n      addedCount: addedCount\n    };\n  }\n\n  var EDIT_LEAVE = 0;\n  var EDIT_UPDATE = 1;\n  var EDIT_ADD = 2;\n  var EDIT_DELETE = 3;\n\n  function ArraySplice() {}\n\n  ArraySplice.prototype = {\n\n    // Note: This function is *based* on the computation of the Levenshtein\n    // \"edit\" distance. The one change is that \"updates\" are treated as two\n    // edits - not one. With Array splices, an update is really a delete\n    // followed by an add. By retaining this, we optimize for \"keeping\" the\n    // maximum array items in the original array. For example:\n    //\n    //   'xxxx123' -> '123yyyy'\n    //\n    // With 1-edit updates, the shortest path would be just to update all seven\n    // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n    // leaves the substring '123' intact.\n    calcEditDistances: function(current, currentStart, currentEnd,\n                                old, oldStart, oldEnd) {\n      // \"Deletion\" columns\n      var rowCount = oldEnd - oldStart + 1;\n      var columnCount = currentEnd - currentStart + 1;\n      var distances = new Array(rowCount);\n\n      var i, j;\n\n      // \"Addition\" rows. Initialize null column.\n      for (i = 0; i < rowCount; i++) {\n        distances[i] = new Array(columnCount);\n        distances[i][0] = i;\n      }\n\n      // Initialize null row\n      for (j = 0; j < columnCount; j++)\n        distances[0][j] = j;\n\n      for (i = 1; i < rowCount; i++) {\n        for (j = 1; j < columnCount; j++) {\n          if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))\n            distances[i][j] = distances[i - 1][j - 1];\n          else {\n            var north = distances[i - 1][j] + 1;\n            var west = distances[i][j - 1] + 1;\n            distances[i][j] = north < west ? north : west;\n          }\n        }\n      }\n\n      return distances;\n    },\n\n    // This starts at the final weight, and walks \"backward\" by finding\n    // the minimum previous weight recursively until the origin of the weight\n    // matrix.\n    spliceOperationsFromEditDistances: function(distances) {\n      var i = distances.length - 1;\n      var j = distances[0].length - 1;\n      var current = distances[i][j];\n      var edits = [];\n      while (i > 0 || j > 0) {\n        if (i == 0) {\n          edits.push(EDIT_ADD);\n          j--;\n          continue;\n        }\n        if (j == 0) {\n          edits.push(EDIT_DELETE);\n          i--;\n          continue;\n        }\n        var northWest = distances[i - 1][j - 1];\n        var west = distances[i - 1][j];\n        var north = distances[i][j - 1];\n\n        var min;\n        if (west < north)\n          min = west < northWest ? west : northWest;\n        else\n          min = north < northWest ? north : northWest;\n\n        if (min == northWest) {\n          if (northWest == current) {\n            edits.push(EDIT_LEAVE);\n          } else {\n            edits.push(EDIT_UPDATE);\n            current = northWest;\n          }\n          i--;\n          j--;\n        } else if (min == west) {\n          edits.push(EDIT_DELETE);\n          i--;\n          current = west;\n        } else {\n          edits.push(EDIT_ADD);\n          j--;\n          current = north;\n        }\n      }\n\n      edits.reverse();\n      return edits;\n    },\n\n    /**\n     * Splice Projection functions:\n     *\n     * A splice map is a representation of how a previous array of items\n     * was transformed into a new array of items. Conceptually it is a list of\n     * tuples of\n     *\n     *   <index, removed, addedCount>\n     *\n     * which are kept in ascending index order of. The tuple represents that at\n     * the |index|, |removed| sequence of items were removed, and counting forward\n     * from |index|, |addedCount| items were added.\n     */\n\n    /**\n     * Lacking individual splice mutation information, the minimal set of\n     * splices can be synthesized given the previous state and final state of an\n     * array. The basic approach is to calculate the edit distance matrix and\n     * choose the shortest path through it.\n     *\n     * Complexity: O(l * p)\n     *   l: The length of the current array\n     *   p: The length of the old array\n     */\n    calcSplices: function(current, currentStart, currentEnd,\n                          old, oldStart, oldEnd) {\n      var prefixCount = 0;\n      var suffixCount = 0;\n\n      var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n      if (currentStart == 0 && oldStart == 0)\n        prefixCount = this.sharedPrefix(current, old, minLength);\n\n      if (currentEnd == current.length && oldEnd == old.length)\n        suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n\n      currentStart += prefixCount;\n      oldStart += prefixCount;\n      currentEnd -= suffixCount;\n      oldEnd -= suffixCount;\n\n      if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\n        return [];\n\n      var splice;\n      if (currentStart == currentEnd) {\n        splice = newSplice(currentStart, [], 0);\n        while (oldStart < oldEnd)\n          splice.removed.push(old[oldStart++]);\n\n        return [ splice ];\n      } else if (oldStart == oldEnd)\n        return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\n      var ops = this.spliceOperationsFromEditDistances(\n          this.calcEditDistances(current, currentStart, currentEnd,\n                                 old, oldStart, oldEnd));\n\n      var splices = [];\n      var index = currentStart;\n      var oldIndex = oldStart;\n      for (var i = 0; i < ops.length; i++) {\n        switch(ops[i]) {\n          case EDIT_LEAVE:\n            if (splice) {\n              splices.push(splice);\n              splice = undefined;\n            }\n\n            index++;\n            oldIndex++;\n            break;\n          case EDIT_UPDATE:\n            if (!splice)\n              splice = newSplice(index, [], 0);\n\n            splice.addedCount++;\n            index++;\n\n            splice.removed.push(old[oldIndex]);\n            oldIndex++;\n            break;\n          case EDIT_ADD:\n            if (!splice)\n              splice = newSplice(index, [], 0);\n\n            splice.addedCount++;\n            index++;\n            break;\n          case EDIT_DELETE:\n            if (!splice)\n              splice = newSplice(index, [], 0);\n\n            splice.removed.push(old[oldIndex]);\n            oldIndex++;\n            break;\n        }\n      }\n\n      if (splice) {\n        splices.push(splice);\n      }\n      return splices;\n    },\n\n    sharedPrefix: function(current, old, searchLength) {\n      for (var i = 0; i < searchLength; i++)\n        if (!this.equals(current[i], old[i]))\n          return i;\n      return searchLength;\n    },\n\n    sharedSuffix: function(current, old, searchLength) {\n      var index1 = current.length;\n      var index2 = old.length;\n      var count = 0;\n      while (count < searchLength && this.equals(current[--index1], old[--index2]))\n        count++;\n\n      return count;\n    },\n\n    calculateSplices: function(current, previous) {\n      return this.calcSplices(current, 0, current.length, previous, 0,\n                              previous.length);\n    },\n\n    equals: function(currentValue, previousValue) {\n      return currentValue === previousValue;\n    }\n  };\n\n  var arraySplice = new ArraySplice();\n\n  function calcSplices(current, currentStart, currentEnd,\n                       old, oldStart, oldEnd) {\n    return arraySplice.calcSplices(current, currentStart, currentEnd,\n                                   old, oldStart, oldEnd);\n  }\n\n  function intersect(start1, end1, start2, end2) {\n    // Disjoint\n    if (end1 < start2 || end2 < start1)\n      return -1;\n\n    // Adjacent\n    if (end1 == start2 || end2 == start1)\n      return 0;\n\n    // Non-zero intersect, span1 first\n    if (start1 < start2) {\n      if (end1 < end2)\n        return end1 - start2; // Overlap\n      else\n        return end2 - start2; // Contained\n    } else {\n      // Non-zero intersect, span2 first\n      if (end2 < end1)\n        return end2 - start1; // Overlap\n      else\n        return end1 - start1; // Contained\n    }\n  }\n\n  function mergeSplice(splices, index, removed, addedCount) {\n\n    var splice = newSplice(index, removed, addedCount);\n\n    var inserted = false;\n    var insertionOffset = 0;\n\n    for (var i = 0; i < splices.length; i++) {\n      var current = splices[i];\n      current.index += insertionOffset;\n\n      if (inserted)\n        continue;\n\n      var intersectCount = intersect(splice.index,\n                                     splice.index + splice.removed.length,\n                                     current.index,\n                                     current.index + current.addedCount);\n\n      if (intersectCount >= 0) {\n        // Merge the two splices\n\n        splices.splice(i, 1);\n        i--;\n\n        insertionOffset -= current.addedCount - current.removed.length;\n\n        splice.addedCount += current.addedCount - intersectCount;\n        var deleteCount = splice.removed.length +\n                          current.removed.length - intersectCount;\n\n        if (!splice.addedCount && !deleteCount) {\n          // merged splice is a noop. discard.\n          inserted = true;\n        } else {\n          removed = current.removed;\n\n          if (splice.index < current.index) {\n            // some prefix of splice.removed is prepended to current.removed.\n            var prepend = splice.removed.slice(0, current.index - splice.index);\n            Array.prototype.push.apply(prepend, removed);\n            removed = prepend;\n          }\n\n          if (splice.index + splice.removed.length > current.index + current.addedCount) {\n            // some suffix of splice.removed is appended to current.removed.\n            var append = splice.removed.slice(current.index + current.addedCount - splice.index);\n            Array.prototype.push.apply(removed, append);\n          }\n\n          splice.removed = removed;\n          if (current.index < splice.index) {\n            splice.index = current.index;\n          }\n        }\n      } else if (splice.index < current.index) {\n        // Insert splice here.\n\n        inserted = true;\n\n        splices.splice(i, 0, splice);\n        i++;\n\n        var offset = splice.addedCount - splice.removed.length;\n        current.index += offset;\n        insertionOffset += offset;\n      }\n    }\n\n    if (!inserted)\n      splices.push(splice);\n  }\n\n  function createInitialSplices(array, changeRecords) {\n    var splices = [];\n\n    for (var i = 0; i < changeRecords.length; i++) {\n      var record = changeRecords[i];\n      switch(record.type) {\n        case 'splice':\n          mergeSplice(splices, record.index, record.removed.slice(), record.addedCount);\n          break;\n        case 'add':\n        case 'update':\n        case 'delete':\n          if (!isIndex(record.name))\n            continue;\n          var index = toNumber(record.name);\n          if (index < 0)\n            continue;\n          mergeSplice(splices, index, [record.oldValue], 1);\n          break;\n        default:\n          console.error('Unexpected record type: ' + JSON.stringify(record));\n          break;\n      }\n    }\n\n    return splices;\n  }\n\n  function projectArraySplices(array, changeRecords) {\n    var splices = [];\n\n    createInitialSplices(array, changeRecords).forEach(function(splice) {\n      if (splice.addedCount == 1 && splice.removed.length == 1) {\n        if (splice.removed[0] !== array[splice.index])\n          splices.push(splice);\n\n        return;\n      }\n\n      splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount,\n                                           splice.removed, 0, splice.removed.length));\n    });\n\n    return splices;\n  }\n\n  // Export the observe-js object for **Node.js**, with backwards-compatibility\n  // for the old `require()` API. Also ensure `exports` is not a DOM Element.\n  // If we're in the browser, export as a global object.\n\n  var expose = global;\n\n  if (typeof exports !== 'undefined' && !exports.nodeType) {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports;\n    }\n    expose = exports;\n  }\n\n  expose.Observer = Observer;\n  expose.Observer.runEOM_ = runEOM;\n  expose.Observer.observerSentinel_ = observerSentinel; // for testing.\n  expose.Observer.hasObjectObserve = hasObserve;\n  expose.ArrayObserver = ArrayObserver;\n  expose.ArrayObserver.calculateSplices = function(current, previous) {\n    return arraySplice.calculateSplices(current, previous);\n  };\n\n  expose.ArraySplice = ArraySplice;\n  expose.ObjectObserver = ObjectObserver;\n  expose.PathObserver = PathObserver;\n  expose.CompoundObserver = CompoundObserver;\n  expose.Path = Path;\n  expose.ObserverTransform = ObserverTransform;\n\n})(typeof global !== 'undefined' && global && typeof module !== 'undefined' && module ? global : this || window);\n"]}